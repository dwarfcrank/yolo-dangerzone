#include "stdafx.h"
#include "util/block.h"

#include <boost/test/unit_test.hpp>

#include <cstdint>
#include <vector>

// A 1x1 block. This should result in one 8x8 block, with the first row
// and column repeated with this byte.
static const std::uint8_t TEST_BLOCK_1X1[] =
{
    0xAA,
};

static const std::uint8_t EXPECTED_BLOCK_1X1[] =
{
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// A 9x8 block. This should result in two blocks with the rightmost column repeated.
static const std::uint8_t TEST_BLOCK_9X8[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
};

static const std::uint8_t EXPECTED_BLOCKS_9X8[] =
{
    // Block 1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Block 2
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
};

// A 9x9 block. This should result in four blocks, one with the rightmost column repeated,
// one with the topmost row repeated and one with the upper-left corner repeated (see the 1x1 block).
static const std::uint8_t TEST_BLOCK_9X9[] =
{
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xCC,
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xCC,
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xCC,
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xCC,
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xCC,
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xCC,
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xCC,
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xCC,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xBB, 
};

static const std::uint8_t EXPECTED_BLOCKS_9X9[] =
{
    // Block 1
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 

    // Block 2
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 

    // Block 3
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 

    // Block 4
    0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 
    0xBB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xBB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xBB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xBB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xBB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xBB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xBB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

static const std::uint8_t* ComputeBlockAddress(const std::uint8_t* BlockBase, int BlockIndex)
{
    return BlockBase + BlockIndex * 64;
}

BOOST_AUTO_TEST_CASE(TestSplit1x1)
{
    std::vector<Uint8Block> blocks;
    std::vector<std::uint8_t> pixels(TEST_BLOCK_1X1, TEST_BLOCK_1X1 + sizeof(TEST_BLOCK_1X1));

    Util::SplitBlocks(pixels, 1, 1, &blocks);

    BOOST_CHECK_EQUAL(blocks.size(), 1);

    const Uint8Block& block = blocks[0];
    BOOST_CHECK_EQUAL_COLLECTIONS(block.cbegin(), block.cend(),
        EXPECTED_BLOCK_1X1, EXPECTED_BLOCK_1X1 + sizeof(EXPECTED_BLOCK_1X1));
}

BOOST_AUTO_TEST_CASE(TestSplit9x8)
{
    std::vector<Uint8Block> blocks;
    std::vector<std::uint8_t> pixels(TEST_BLOCK_9X8, TEST_BLOCK_9X8 + sizeof(TEST_BLOCK_9X8));

    Util::SplitBlocks(pixels, 9, 8, &blocks);

    BOOST_CHECK_EQUAL(blocks.size(), 2);

    for (int i = 0; i < blocks.size(); i++) {
        const Uint8Block& block = blocks[i];
        const std::uint8_t* expected = ComputeBlockAddress(EXPECTED_BLOCKS_9X8, i);
        
        BOOST_CHECK_EQUAL_COLLECTIONS(block.cbegin(), block.cend(),
            expected, expected + 64);
    }
}

BOOST_AUTO_TEST_CASE(TestSplit9x9)
{
    std::vector<Uint8Block> blocks;
    std::vector<std::uint8_t> pixels(TEST_BLOCK_9X9, TEST_BLOCK_9X9 + sizeof(TEST_BLOCK_9X9));

    Util::SplitBlocks(pixels, 9, 9, &blocks);

    BOOST_CHECK_EQUAL(blocks.size(), 4);

    for (int i = 0; i < blocks.size(); i++) {
        const Uint8Block& block = blocks[i];
        const std::uint8_t* expected = ComputeBlockAddress(EXPECTED_BLOCKS_9X9, i);
        
        BOOST_CHECK_EQUAL_COLLECTIONS(block.cbegin(), block.cend(),
            expected, expected + 64);
    }
}
